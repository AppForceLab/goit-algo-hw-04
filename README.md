# Аналіз ефективності алгоритмів сортування

## Вступ
Python має дві вбудовані функції сортування: `sorted` і `sort`. Вони використовують алгоритм **Timsort**, який поєднує в собі **сортування злиттям** та **сортування вставками**. У цьому дослідженні ми порівняємо три алгоритми: **сортування вставками**, **сортування злиттям** та **Timsort**, перевіряючи їхню ефективність на різних наборах даних.

## Теоретична складність алгоритмів

| Алгоритм              | Найгірший випадок | Середній випадок | Найкращий випадок |
|----------------------|----------------|----------------|----------------|
| Сортування вставками | O(n²)         | O(n²)         | O(n)          |
| Сортування злиттям   | O(n log n)    | O(n log n)    | O(n log n)    |
| Timsort              | O(n log n)    | O(n log n)    | O(n)          |

## Методика експерименту
- **Вхідні дані:** Масиви випадкових чисел різного розміру: 100, 500, 1000, 5000, 10000, 50000 елементів.
- **Інструмент замірів:** Модуль `timeit` у Python.
- **Алгоритми:** Реалізовані на Python **сортування вставками** та **сортування злиттям**, а також використано вбудований `sorted()` (Timsort).
- **Обмеження:** Сортування вставками протестоване лише на менших масивах (до 1000 елементів), оскільки воно занадто повільне.

## Результати тестування
(Результати представлені у таблиці, візуалізовані на графіку)

### Висновки
1. **Сортування вставками** є надзвичайно повільним на великих масивах, що підтверджує його O(n²) складність.
2. **Сортування злиттям** працює швидше і показує стабільний O(n log n) час виконання.
3. **Timsort значно ефективніший**, оскільки використовує сортування вставками для малих підмасивів, що покращує продуктивність.
4. **Python використовує Timsort у `sorted()` та `sort()`**, оскільки він забезпечує швидку та стабільну роботу для реальних сценаріїв використання.

Таким чином, програмісти рідко реалізують алгоритми сортування самостійно, оскільки вбудовані методи Python є оптимізованими для більшості випадків.
